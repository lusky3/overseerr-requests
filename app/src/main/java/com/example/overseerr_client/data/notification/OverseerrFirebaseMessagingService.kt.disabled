package com.example.overseerr_client.data.notification

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.example.overseerr_client.MainActivity
import com.example.overseerr_client.R
import com.example.overseerr_client.domain.model.Notification
import com.example.overseerr_client.domain.model.NotificationType
import com.example.overseerr_client.domain.repository.NotificationRepository
import com.example.overseerr_client.domain.repository.SettingsRepository
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.util.UUID
import javax.inject.Inject

/**
 * Firebase Cloud Messaging service for handling push notifications.
 * Feature: overseerr-android-client
 * Validates: Requirements 6.1, 6.2, 6.3, 6.4
 * Property 24: Status Change Notifications
 * Property 25: Notification Deep Link Navigation
 * Property 26: Notification Preference Respect
 * 
 * Note: Cannot use @AndroidEntryPoint with FirebaseMessagingService.
 * Dependencies are injected manually via EntryPointAccessors.
 */
class OverseerrFirebaseMessagingService : FirebaseMessagingService() {
    
    private lateinit var notificationRepository: NotificationRepository
    private lateinit var settingsRepository: SettingsRepository
    
    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    companion object {
        private const val CHANNEL_ID_APPROVED = "request_approved"
        private const val CHANNEL_ID_AVAILABLE = "request_available"
        private const val CHANNEL_ID_DECLINED = "request_declined"
        private const val CHANNEL_ID_SYSTEM = "system"
        
        private const val NOTIFICATION_ID_BASE = 1000
    }
    
    override fun onCreate() {
        super.onCreate()
        
        // Manual dependency injection using Hilt EntryPointAccessors
        val entryPoint = dagger.hilt.android.EntryPointAccessors.fromApplication(
            applicationContext,
            OverseerrFirebaseMessagingServiceEntryPoint::class.java
        )
        notificationRepository = entryPoint.notificationRepository()
        settingsRepository = entryPoint.settingsRepository()
        
        createNotificationChannels()
    }
    
    override fun onNewToken(token: String) {
        super.onNewToken(token)
        
        // Register new token with Overseerr server
        serviceScope.launch {
            notificationRepository.registerForPushNotifications(token)
        }
    }
    
    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)
        
        serviceScope.launch {
            handleNotification(message)
        }
    }
    
    private suspend fun handleNotification(message: RemoteMessage) {
        // Check notification settings
        val settings = settingsRepository.getNotificationSettings().first()
        
        if (!settings.enabled) {
            // Notifications are disabled, don't show
            return
        }
        
        // Parse notification data
        val data = message.data
        val title = data["title"] ?: message.notification?.title ?: "Overseerr"
        val body = data["body"] ?: message.notification?.body ?: ""
        val typeString = data["type"] ?: "SYSTEM"
        val deepLink = data["deepLink"]
        val mediaId = data["mediaId"]?.toIntOrNull()
        val requestId = data["requestId"]?.toIntOrNull()
        
        // Determine notification type
        val notificationType = try {
            NotificationType.valueOf(typeString)
        } catch (e: IllegalArgumentException) {
            NotificationType.SYSTEM
        }
        
        // Check if this notification type is enabled
        val shouldShow = when (notificationType) {
            NotificationType.REQUEST_APPROVED -> settings.requestApproved
            NotificationType.REQUEST_AVAILABLE -> settings.requestAvailable
            NotificationType.REQUEST_DECLINED -> settings.requestDeclined
            else -> true
        }
        
        if (!shouldShow) {
            // This notification type is disabled
            return
        }
        
        // Create notification object
        val notification = Notification(
            id = UUID.randomUUID().toString(),
            title = title,
            body = body,
            type = notificationType,
            timestamp = System.currentTimeMillis(),
            isRead = false,
            deepLink = deepLink,
            mediaId = mediaId,
            requestId = requestId
        )
        
        // Save to history
        notificationRepository.saveNotification(notification)
        
        // Show system notification
        showSystemNotification(notification)
    }
    
    private fun showSystemNotification(notification: Notification) {
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        // Determine channel ID based on notification type
        val channelId = when (notification.type) {
            NotificationType.REQUEST_APPROVED -> CHANNEL_ID_APPROVED
            NotificationType.REQUEST_AVAILABLE -> CHANNEL_ID_AVAILABLE
            NotificationType.REQUEST_DECLINED -> CHANNEL_ID_DECLINED
            else -> CHANNEL_ID_SYSTEM
        }
        
        // Create intent for notification tap
        val intent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            notification.deepLink?.let { putExtra("deepLink", it) }
            notification.requestId?.let { putExtra("requestId", it) }
            notification.mediaId?.let { putExtra("mediaId", it) }
        }
        
        val pendingIntent = PendingIntent.getActivity(
            this,
            notification.id.hashCode(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        // Build notification
        val notificationBuilder = NotificationCompat.Builder(this, channelId)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle(notification.title)
            .setContentText(notification.body)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
        
        // Show notification
        notificationManager.notify(
            NOTIFICATION_ID_BASE + notification.id.hashCode(),
            notificationBuilder.build()
        )
    }
    
    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            
            // Request Approved Channel
            val approvedChannel = NotificationChannel(
                CHANNEL_ID_APPROVED,
                "Request Approved",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Notifications when your requests are approved"
            }
            
            // Request Available Channel
            val availableChannel = NotificationChannel(
                CHANNEL_ID_AVAILABLE,
                "Request Available",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Notifications when requested media becomes available"
            }
            
            // Request Declined Channel
            val declinedChannel = NotificationChannel(
                CHANNEL_ID_DECLINED,
                "Request Declined",
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "Notifications when your requests are declined"
            }
            
            // System Channel
            val systemChannel = NotificationChannel(
                CHANNEL_ID_SYSTEM,
                "System",
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "System notifications"
            }
            
            // Register channels
            notificationManager.createNotificationChannel(approvedChannel)
            notificationManager.createNotificationChannel(availableChannel)
            notificationManager.createNotificationChannel(declinedChannel)
            notificationManager.createNotificationChannel(systemChannel)
        }
    }
}

/**
 * Hilt EntryPoint for manual dependency injection in FirebaseMessagingService.
 * Required because @AndroidEntryPoint cannot be used with FirebaseMessagingService.
 */
@dagger.hilt.EntryPoint
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
interface OverseerrFirebaseMessagingServiceEntryPoint {
    fun notificationRepository(): NotificationRepository
    fun settingsRepository(): SettingsRepository
}
